# UPnP-terminal

To use this code you have to install python `requests` and download this repository. With 'py upnpTerminal.py' you can start the program. 
There are different options how to start the program. With `--info` additional information about the project are displayed and `--empty`
will start the program in manual mode in the future.

After the database is initialized with the received data from the network, an interpreter is started. You will start in the `system`
-context. Enter the name of the context you want to switch to and `exit` to get back to the default one. The usage
can be seen with `help` in each context.

There are three contexts implemented:

### msearch 

---

The MSearchContext (name: `msearch`) is used to analyze the received packets during the collection process. The following commands are implemented:
    
    > hosts [--save PATH]

    save              writes all collected hosts to the specified path
                      (format=XXX will be added in the future)

### devices

---

The DeviceContext (name: `devices`) is used to get detailed information about collected devices, services and service-descriptions. The 
commands are the following ones:
    
    > device [--host HOST] [--name NAME]

    host               the host-address is used to get all devices
                       from that address.
    name               searches for devices wth the given name. If both
                       options are set only 'host' is used
    all                prints all information about stored services
                        

    > service [--name NAME]

    name              only services with the given name will be printed. 

                          
    > scpd [--host HOST_ADDRESS] [--name NAME] [--code PATH] 

    host              prints all service-presentation-descriptions linked 
                      to the host
    name              only services with the given name are printed. It 
                      is recommended to use both options in order to get 
                      less output (it will be huge).
    code              creates a pseudocode document with all actions and
                      variables

An axample of code generated by this script can be seen in the file `"example-code.txt".` Type definitions are written as follows:

    //standard type
    define [eventing] type_name as type_reference

    //type with a default value
    with values (
        default value1
    ) define [eventing] type_name as type_reference

    //type with allowed values
    with values (
        value1
        value2
        ...
    ) define [eventing] type_name as type_reference

and methods like this:

    //void method
    [optional] void def method_name(method_parameters);

    //method with return value
    [optional] def method_name(method_parameters):
    type_reference "var + type_name" = __sub__0Gettype_name(...)
    ...

    return "var + type_name", ...

### control

---

The ControlContext is used to execute commands on UPnP-Devices. To get a
feeling of the structure of the declared functions just use the 'code'
option on 'scpd' in the DeviceContext. This generates a file with pseudocode
with all global type-definitions and declared methods.
    
The 'exe' command uses the method-name as an identifier to collect all other 
details like 'serviceType' or 'controlURL'. If some arguments are required
the parameter-name is the same as defined in the pseudocode. 

Let's consider the following example: 
        
    string A_ARG_TYPE_InstanceID

If an argument of the example type is required, the following structure should
be used:

    --argv InstanceID:someString
  
The following commands are implemented:
    
    > exe --method METHOD [--argv ParamName:Value[,ParamName:Value[,...]]]

    method            specifies the method name
    argv              if arguments are required, this option has to be used.
                      the structure is described above
